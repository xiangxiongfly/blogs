[TOC]

# JVM 运行时数据区

## 概述

JVM运行时数据区也被称为内存结构，主要有五部分组成：

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区



## [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/)



## 内存结构图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210427143444653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE0ODc2MTMz,size_16,color_FFFFFF,t_70)



## 程序计数器

**说明：**

- 程序计数器是一块很小的内存空间，主要用于记录各个线程执行的字节码地址，如：分支、循环、跳转、异常、线程恢复等都依赖于程序计数器。
- 由于Java是多线程语言，当执行的线程数超过CPU核心数时，线程之间会根据时间片轮询争夺CPU资源。如果一个线程的时间片用完了，或其他原因导致这个现成的CPU资源被抢夺了，那么这个线程就需要用程序计数器来记录下一条运行的指令。

**特点：**

- 线程私有。
- 不会发生内存溢出。



## 虚拟机栈

**虚拟机栈结构：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/3026e5dc2f37449497a0d0ad3a51f339.png)

**说明：**

- 栈：
  - 先进后出的数据结构。
  - 线程创建运行时会对应创建一个虚拟机栈，用于存储当前线程执行方法所需的数据、指令、返回地址。
  - 栈的生命周期和线程一样的。
- 栈帧：
  - 每个Java方法被调用时，都会在栈中创建一个栈帧，并入栈，方法执行完后会出栈。当所有的栈帧都出栈后线程也就结束了。
- 栈帧的组成：
  - 局部变量表：存储方法参数和方法内部定义的局部变量。
  - 操作数栈：栈结构，存放执行过程中的临时数据。
  - 动态链接：将符号引用转换为直接引用。
  - 返回地址：方法执行完后程序应该跳转的位置。

**特点：**

- 线程私有。
- 栈的生命周期与线程相同。

**栈内存溢出问题：**

- 栈帧过多导致内存溢出，JVM会抛出 StackOverflowError 异常，如方法递归调用。
- 栈帧过大导致内存溢出，JVM会抛出 OutOfMemoryError 异常。

### 局部变量表

存储方法参数和方法中的局部变量。

可以通过**jclasslib**插件查看字节码信息。

**成员方法：**

```java
public void sayHello(int param) {
    String text = "hhh";
    System.out.println(text + age);
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/81485cd5e5e540ecb4641149ffb64226.png)

说明：局部变量表里有3个局部变量，包含this对象、方法里的参数和text局部变量。

**静态方法：**

```java
public static void sayHi(int[] args) {
    String hi = "hihhii";
    System.out.println(hi);
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/9575b78760014fd8adb81e143c2757bd.png)

说明：局部变量表里有2个局部变量，没有了this对象。

### 操作数栈

字节码指令在执行过程中，存放计算的临时数据。

```java
public int work() {
    int x = 1;
    int y = 2;
    int z = (x + y) * 10;
    return z;
}
```

**字节码指令分析：**

```
0 iconst_1 	将int类型1入操作数栈
1 istore_1 	将操作数栈中栈顶int类型值，存入局部变量表
2 iconst_2 	将int类型2入操作数栈
3 istore_2 	将操作数栈中栈顶int类型值，存入局部变量表
4 iload_1		将局部变量表中下标为1的int类型数据入栈
5 iload_2		将局部变量表中下标为2的int类型数据入栈
6 iadd			两数相加，将结果入操作数栈
7 bipush 10		将10的压入操作数栈
9 imul			两数相乘，将结果压入操作数栈
10 istore_3		将操作数栈中栈顶int类型值，存入局部变量表
11 iload_3		将局部变量表中下标为3的int类型值入栈
12 ireturn		返回栈顶值
```

### 动态链接

将字节码中的符号引用转为内存中的直接引用。

栈帧的空间是有限的，不能直接存储对象的信息，通过转换为直接引用，就可以在JVM方法区中找到类信息。

**Java代码：**

```java
public class Test {
    public static void main(String[] args) {
        Person p = new Person();
        p.sayHello();
    }
}
```

**字节码指令：**

```
 0 new #2 <com/example/java_demo/Person>
 3 dup
 4 invokespecial #3 <com/example/java_demo/Person.<init> : ()V>
 7 astore_1
 8 aload_1
 9 invokevirtual #4 <com/example/java_demo/Person.sayHello : ()V>
12 return
```

说明：`#2` 指向方法区中的类信息。

### 返回地址

返回地址是指向方法执行完后，程序应该返回的代码行。

例子：假设正在执行A方法，在A方法中又调用了B方法，那么在调用B方法的时候，虚拟机栈会在栈帧中保存一个返回地址，这个地址指向A方法调用B方法的那条指令单下一条指令，B方法执行完后程序就会跳转到这个返回地址，也就是回到A方法中继续执行。



## 本地方法栈

**说明：**

- 本地方法栈与虚拟机栈作用类似，虚拟机栈执行Java方法，本地方法栈执行native方法（一般由C语言实现）。

**特点：**

- 是线程私有的。
- 会抛出OOM和StackOverFlowError。



## 堆

**说明：**

- 堆区在JVM启动的时被创建，空间大小也就确定了，是JVM管理的最大一块内存。
- 用于存放对象实例和数组，在栈中持有引用，引用指向堆中的位置，堆是Java内存管理的核心区域。
- 堆物理上可以是不连续的内存空间，但在逻辑上它是连续的。
- 运行期动态分配内存大小，方法结束后，堆中的对象不会马上被移除，在垃圾收集时才会被移除。
- 是线程共享的，需要考虑线程安全问题。
- 堆中包含线程私有缓冲区（TLAB），可以有效提高JVM的并发效率。

**特点：**

- 线程共享。
- 物理上是分散的，逻辑上是连续的。

**堆结构：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/5541796fc79f4ab19d0937cb1bf90741.png)

- 新生代区：占堆内存的1/3。
  - Eden区：占新生代区8/10。
  - From区：占新生代区1/10。
  - To区：占新生代区1/10。
- 老年代区：占堆内存的2/3。

**堆内存溢出问题：**

- 堆内存不足时虚拟机会抛出 OutOfMemoryError 异常。



## 方法区

**方法区结构：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/5139a8d4423f4f029f48c6a25edde622.png)

**说明：**

- Java方法区是JVM的规范的一部分，不同的虚拟机可能是不一样的。HotSpot虚拟机中，Java 8之前，用永久代实现了方法区；Java 8中采用元空间，使用本地内存，不受JVM限制。
- 是线程共享的。

**存放的内容：**

- 类的元数据：
  - 类名、父类、实现的接口、字段、方法等。
- 类的静态变量。
- 常量池：类文件在编译时生成的字面量和符号引用。
- JIT代码缓存：及时编译器编译后的代码。

**特点：**

- 线程共享。

**其他：**

- 在JDK1.7中，永久代中的静态变量和字符串常量池移到堆中。
- 在JDK1.8中，用元空间替代了永久代。



## 其他问题

### 成员变量 & 局部变量

- 成员变量存放在堆内存，是对象实例的一部分。
- 局部变量存放在虚拟机栈的栈帧中的局部变量表。



### 字面量 & 符号引用 & 直接引用

字面量：

-   字符串
-   final定义的常量值

符号引用：指一组符号描述所引用的目标。符号引用的字面量形式明确定义在“Java虚拟机规范”的Class文件格式中。

-   类和接口的全限定名
-   字段的名称和描述符
-   方法的名称和描述符

直接引用：指直接指向目标的指针、相对偏移量或要给间接定位到目标的句柄。类加载时会将符号引用转为直接引用。



### 垃圾回收是否涉及栈内存

垃圾回收不会涉及栈内存，因为栈内存是一次次的方法调用产生的栈帧内存，方法调用结束后，虚拟机栈会做出栈操作，自动回收内存。垃圾回收只会回收堆内存中无用的对象。


