[TOC]

# JVM内存结构

## 概述

JVM内存结构也被称为运行时数据区，主要有五部分组成：

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 方法区

Java代码编译成字节码文件，需要先加载到方法区中，才能在Java虚拟机中运行。



## [官方文档](https://docs.oracle.com/javase/specs/jvms/se8/html/)



## 内存结构图

![在这里插入图片描述](https://img-blog.csdnimg.cn/4bd060344af046869e10ad868c7ecb6d.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210427143444653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE0ODc2MTMz,size_16,color_FFFFFF,t_70)



## 程序计数器

**作用：**

- Java是多线程语言，假设线程数大于CPU数，可能会出现线程切换现象，线程切换意味着中断和恢复，需要一块内存来保存当前线程的执行信息。
- 每个线程拥有一个程序计数器。程序寄存器用来存储指向下一条指令的地址，即将要执行的指令代码（分支、循环、跳转、异常、线程中断恢复等）。

**特点：**

- 线程私有的。
- 不会发生内存溢出。



## 虚拟机栈

![在这里插入图片描述](https://img-blog.csdnimg.cn/f3439e0774684a39a31d446d437a3f3e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_11,color_FFFFFF,t_70,g_se,x_16)

**定义：**

- 栈是运行时的单位，而堆是存储的单位。也就是说，栈是解决程序运行问题，即程序是如何运行的、保存方法中的局部变量和部分结果，堆是解决数据存储问题，即数据放在什么位置。
- 每个线程在创建时都会创建一个虚拟机栈，是线程私有的。
- 每个栈内部包含多个栈帧，每次方法调用都会创建一个栈帧。
- 每个栈帧会包含：局部变量表、操作数栈、动态连接、方法返回地址。
  - 局部变量表：存储方法参数、定义在方法体内的局部变量，包含基本数据类型、对象引用、返回地址类型。
  - 操作数栈：用于保存计算过程中的中间结果，方法执行过程中，根据字节码指令，往栈中写入或获取数据，即入栈和出栈。
  - 动态连接：指向运行时常量池的方法引用。
  - 方法返回地址：方法正常退出和异常退出的定义。
- 每个栈只能有一个活动栈帧，对应正在执行的方法。
- 栈道操作只有两个：入栈、出栈。方法执行结束后作出栈操作，栈帧里的内容会销毁。

**栈内存溢出问题：**

- 栈帧过多导致内存溢出，JVM会抛出StackOverflowError异常，如方法递归调用。
- 栈帧过大导致内存溢出，JVM会抛出OutOfMemoryError异常。



## 本地方法栈

- 本地方法栈与虚拟机栈作用类似，虚拟机栈执行Java方法，本地方法栈执行native方法（一般由C语言实现）。
- 是线程私有的。
- 会抛出OOM和StackOverFlowError。



## 堆

**定义：**

- 堆区在JVM启动的时被创建，空间大小也就确定了，是JVM管理的最大一块内存。
- 所有的对象实例和数组都分配在堆上，在栈中保存引用，引用指向堆中的位置，堆是Java内存管理的核心区域。
- 堆物理上可以是不连续的内存空间，但在逻辑上它是连续的。
- 运行期动态分配内存大小，方法结束后，堆中的对象不会马上被移除，在垃圾收集时才会被移除。
- 是线程共享的，需要考虑线程安全问题。

**堆结构：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/de5ae2efa1274702a1f47ac20d8c5386.png)

**堆内存溢出问题：**

- 堆内存不足时虚拟机会抛出OutOfMemoryError异常。



## 方法区

![在这里插入图片描述](https://img-blog.csdnimg.cn/e098cc5b5b764424978893863472731e.png)

**定义：**

- Java方法区是JVM的规范的一部分，不同的虚拟机可能是不一样的。
- 方法区在逻辑上是属于堆的一部分，HotSpot虚拟机中，Java 8之前，用永久代实现了方法区；Java 8中采用元空间，不受JVM限制。
- 是线程共享的。

**作用：**

- 方法区主要用来存放类的结构信息，包含：类型信息、运行时常量池、字符串常量池、静态变量、及时编译器编译后的代码缓存等。
- 类型信息包含（类型包括类class、接口interface、枚举enum、注解annotation）：类型的版本、修饰符、字段、方法、接口和常量池表（存储字面量和符号引用）。
- 运行时常量池：存放类加载后生成的直接引用、JIT代码缓存。

**方法区结构：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/ed170e36a3b74b508586d80fda386f91.png)



## 其他问题

### 字面量 & 符号引用 & 直接引用

字面量：

-   字符串
-   final定义的常量值

符号引用：指一组符号描述所引用的目标。符号引用的字面量形式明确定义在“Java虚拟机规范”的Class文件格式中。

-   类和接口的全限定名
-   字段的名称和描述符
-   方法的名称和描述符

直接引用：指直接指向目标的指针、相对偏移量或要给间接定位到目标的句柄。类加载时会将符号引用转为直接引用。



### 成员变量 & 局部变量

- 成员变量存放在堆内存，在类初始化是从运行时常量池（方法区）获取数据，并和初始化对象一起放在堆内存中。
- 局部变量存放在虚拟机栈的栈帧中。



### 垃圾回收是否涉及栈内存

垃圾回收不会涉及栈内存，因为栈内存是一次次的方法调用产生的栈帧内存，方法调用结束后，虚拟机栈会做出栈操作，自动回收内存。垃圾回收只会回收堆内存中无用的对象。



