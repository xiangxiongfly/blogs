[TOC]

# JVM 垃圾回收机制

## 概述

-   垃圾对象：在内存中已经不再被使用到的内存空间就是垃圾对象。
-   Java使用的是自动内存管理机制，有内存分配器和垃圾收集器来代为分配和回收内存。



## 对象存活判断（垃圾标记阶段）

在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，这个过程我们可以称为垃圾标记阶段。在Java虚拟机中，判断对象是否存活的两种方式：

-   引用计数法
-   可达性分析法

### 引用计数法

- 在每个对象中添加一个引用计数器。
- 当对象被引用+1，当对象失去引用-1；引用计数为0时，对象不再被引用，可以被回收。

**优点：**

-   简单
-   高效。

**缺点：**

-   需要单独的字段存储计数器，增加了内存开销；每次赋值需要更新计数器，增加了时间开销。
-   无法解决循环引用问题，目前在Java中几乎不使用这种算法。

```java
objA.name = objB；
objB.name = objA；
```

### 可达性分析法

- Java语言选择使用可达性分析算法判断对象是否存活。
- 可达性分析法：是以 GC Roots（根对象） 为起点，按照从上至下的方式搜索。搜索所走过的路径被称为**引用链**，如果目标对象没有在引用链上，则表示对象是不可达的，可以标记为垃圾对象。

**GC Roots：**

GC Roots 集合就是一组必须活跃的引用。GC Roots 对象包含：

- 虚拟机栈（栈帧中的局部变量表）中引用的对象
- 方法区中的静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象
- 同步锁synchronized持有的对象

![在这里插入图片描述](https://img-blog.csdnimg.cn/2ad80d24b72f46a78d5c5817d7f39b70.png)

### finalize()

Java语言提供了对象终止(finalization)机制来允许开发人员自定义对象被销毁之前的处理逻辑。当垃圾回收器发现没有引用指向一个对象时，通常接下来要做的就是垃圾回收，即清除该对象，而finalization机制使得在清除此对象之前，总会先调用这个对象的finalize()方法。

**不建议使用：**

- 调用 finalize() 方法可能导致对象复活。
- 一个糟糕的finalize()会严重影响GC的性能。
- finalize() 方法的执行时间没有保障的，它完全由GC线程决定。



## 垃圾收集算法

- 标记-清除算法（Mark-Sweep）
- 复制算法（Copying）
- 标记-压缩算法（Mark-Compact）

### 标记-清除算法

**算法过程：**

该算法分标记和清除两个阶段：

- 标记阶段：垃圾收集器从引用根节点开始遍历，标记所有被引用的对象。
- 清除阶段：垃圾收集器对堆内存从头到尾进行线性遍历，如果发现某个对象为不可达对象，则将其回收。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c0e1afdc3644f238dd909845a63cad3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_12,color_FFFFFF,t_70,g_se,x_16)

**优点：**

-   算法简单、实现简单。

**缺点：**

- 效率问题：标记和清除这两个过程效率不高。大部分对象都是朝生夕死的，因此需要大量标记对象和回收对象。
- 空间问题：标记-清除后，会产生大量的内存碎片。内存碎片太多可能会导致需要分配较大对象时，无法找到足够的连续空间，从而提前触发另一次垃圾收集动作。

**场景：**

- 标记-清除算法适合老年代。



### 复制算法

**算法过程：**

- 将内存分为大小相等的两块，每次只使用其中一块。
- 当这一块内存用完了，将这块内存中存活的对象复制到另一块中，然后一次清除使用的那块内存。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4b9b9636d964499786c1bf6a49f934dc.png)

**优点：**

-   效率比标记-清除算法高。
-   不会产生内存碎片问题。

**缺点：**

- 可使用的内存缩小为原来的一半。
- 当存活对象较多时，需要做多次复制操作，效率将变低。

**场景：**

- 复制算法适合新生代。



### 标记-整理算法

与标记-清除算法类似，多了一个中间操作：整理内存。

标记-清除算法是一种非移动式的回收算法，标记-整理是移动式的。

**算法过程：**

- 标记：标记存活对象。
- 整理：将所有存活对象压缩到内存的一端，按顺序排放。
- 清除：统一清除端以外的对象。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c3e7805bb3584965ac07ba2fc0d55813.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_16,color_FFFFFF,t_70,g_se,x_16)

**优点：**

-   一次清除端外区域，比标记-清除算法中的清除效率高。
-   不会产生内存碎片。

**缺点：**

- 移动对象时会触发STW。

**场景：**

- 标记-整理算法适合老年代。

### 对比

|          | 标记-清除            | 标记-压缩 | 复制                       |
| -------- | -------------------- | --------- | -------------------------- |
| 速度     | 中等                 | 最慢      | 最快                       |
| 内存开销 | 少，但会产生内存碎片 | 少        | 通常需要存活对象的两倍大小 |
| 移动对象 | 否                   | 是        | 是                         |



### 分代收集算法

![在这里插入图片描述](https://img-blog.csdnimg.cn/06172595d5ca4b5aa053eab68674e816.png)

现在主流的虚拟机基本都采用 **分代收集算法** ，即根据不同区域特点选择不同垃圾收集算法。

- 根据对象存活周期不同，堆内存分为：新生代和老年代。
  - 新生代占1/3空间。
    - Eden区占8/10
    - From区占1/10
    - To区占1/10
  - 老年代占2/3空间。
- 根据特点选择对应的垃圾收集算法。
  - 新生代：对象存活率低，垃圾回收行为频率高，采用复制算法。
  - 老年代：对象存活率搞，垃圾回收行为频率低，采用标记-整理和标记-清除算法混合实现。

**算法过程：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/778bfb126c144874bd913b6a40fc263f.png)

1. 新创建的对象会先放在Eden区（位于新生代区，该区有大小限制），如果是大对象（如很长的字符串、数组）会直接分配到老年代区，避免频繁的内存复制。
2. 如果Eden区的空间占满，程序又需要创建对象时，会触发MinorGC，将Eden区的存活对象移动到S0区并销毁垃圾对象，新创建的对象会放在Eden区，这是第一轮MinorGC后的操作。
3. 当发生第二轮MinorGC后，会将存活Eden区和S0区的存活对象复制到S1区，并清除Eden区和S0区。
4. 每次MinorGC存活对象的年龄都会加1，当存活对象的年龄达到阀值（默认为15），存活对象会移动到老年代区。
5. 当老年代区内存不足时，会触发MajorGC，对老年代和新生代进行回收。当老年代内存仍不足时，会产生OOM异常。

**优点：**

- 效率高。
- 空间利用率高。

### 增量收集算法

在垃圾回收过程中，应用软件将处于一种STW(Stop The World)的状态。在STW状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。

因此增量收集(Incremental Collecting)算法由此诞生。

增量收集基本思想是如果一次性将所有的垃圾进行处理，会造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，增量收集算法的基础仍是传统的标记–清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。

### 分区收集算法

在相同条件下，堆空间越大，一次GC所需要的时间就越长，有关GC产生的停顿也就越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

分代算法按照对象的生命周期长短将堆空间划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间(region)。每一个小区间都独立使用、独立回收。这种算法的好处是可以控制一次回收多少个小区间。



## Stop-The-World

在垃圾回收过程中，整个应用程序都会暂停，没有任何响应，所以被形象地称为“Stop-The-World”，简称STW。

可达性分析算法中枚举根节点(GC Roots)造成STW，原因是如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。所以分析工作必须在一个能确保一致性的快照中进行。

被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不给力造成电影卡顿一样，体验非常不好，所以我们需要减少STW的发生。



## 垃圾收集器分类

### 性能指标

- 吞吐量：运行用户代码的时间占总运行时间的比例。总运行时间=程序的运行时间+内存回收的时间。
- 垃圾收集开销：吞吐量的补数，内存回收所用时间与总运行时间的比例。
- 停顿时间：执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：Java堆区大小设置。

### 分类

**根据垃圾收集器工作区域分类：**

Java堆分为新生代和老年代，生命周期较短的对象一般放在新生代，生命周期较长的对象会进入老年代。不同区域的对象，采取不同的收集方式，以便提高回收效率。因此根据垃圾收集器工作的内存区间不同，可分为新生代垃圾收集器、老年代垃圾收集器和整堆垃圾收集器。

- 新生代收集器：Serial、ParNew、Parallel Scavenge。
- 老年代收集器：Serial Old、Parallel Old、CMS。
- 整堆收集器：G1。

**根据垃圾收集器工作模式分类：**

串行垃圾收集器是指使用单线程收集垃圾，即使存在多个CPU可用，也只能用一个CPU执行垃圾回收，所以应用程序一定会发生STW。

并行垃圾收集器指使用多个垃圾收集线程并行工作，当多个CPU可用时，并行垃圾收集器会使用多个CPU同时进行垃圾回收，因此提升了应用的吞吐量，但此时用户线程仍会处于等待状态，即STW现象仍然会发生。

并发垃圾收集器是指用户线程与垃圾收集线程“同时”，但此时用户线程和垃圾收集线程不一定是并行的，可能会交替执行。如果此时存在多个CPU或者一个CPU存在多核的情况，垃圾收集线程在执行时不会“停顿”用户程序的运行，即垃圾收集线程不会独占CPU资源，用户程序再继续运行，而垃圾收集程序线程运行于另一个CPU上。

- 串行收集器：Serial、Serial Old。
- 并行收集器：ParNew、Parallel Scavenge、Parallel Old。
- 并发收集器：CMS、G1。

