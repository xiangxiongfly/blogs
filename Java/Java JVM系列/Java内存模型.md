[TOC]

# Java内存模型

## 硬件内存模型

![在这里插入图片描述](https://img-blog.csdnimg.cn/b2edcb4ecb3543229520032853b95b39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_14,color_FFFFFF,t_70,g_se,x_16)



## 并发问题根源

CPU为了提高效率，有了高速缓存、指令重排序等，整体架构变得复杂了。

**指令重排序**：为了提高CPU的运算效率，处理器可能会对输入的代码进行乱序执行，这就是所谓的指令重排序。

**可见性问题**：

一个线程对共享变量的修改，其他线程可以感知到，这就是可见性。

在单核时代，是不存在可见性问题的，因为所有的线程都在一个CPU下工作。但在多核CPU中，每个CPU都有自己的高速缓存，每个核心下的L1/L2高速缓存不共享，多个线程在不同的CPU中处理数据会导致不可见问题。

如：变量a的值是1，两个线程同时执行了a++操作，首先会从内存中读取变量a的值到各自的CPU缓存中，这时两个CPU缓存的a的值都是1，执行a++后，两个变量的值都是2了，然后再写回到内存中，内存中的变量a的值就变为2了，其实我们需要的结果是a=3。

CPU缓存会导致可见性问题。

**原子性问题**：

由于I/O的速度太慢了，操作系统发明了多进程，允许某个进程执行一小段时间后，重新选择一个进程来执行，这个过程被称为任务切换，而这一小段时间被称为时间片。

Java的一条语句往往需要多条CPU指令完成，由于线程切换很可能导致一条语句未执行完，其他线程中途操作了共享变量，导致最终结果并非我们所期待的。

如：a++操作，至少需要3条CPU指令：先把a的值从内存中读取到CPU寄存器中，再在寄存器中执行+1操作，最后将a的值写入内存中（可能写入CPU缓存中）。

线程切换会导致原子性问题。

**有序性问题**：

有序性是指程序按照代码的先后顺序执行。

编译器优化导致重排序（编译器可以在不改变单线程程序语义的情况下，可以对代码孙晓进行调整重排序），指令级并行重排序（CPU原生就有可能将指令进行重排序），内存系统重排序（CPU架构下很有可能有缓冲区，这种异步很可能导致指令重排）。也就是开发人员写的代码顺序与最终执行的顺序不一致。

如：`x=1 y=2`可能被优化为`y=2 x=1`。

指令重排会导致有序性问题。



## Java内存模型

由于不同CPU架构的缓存体系不一样。缓存一致性协议不一样、重排序的策略不一样、所提供的内存屏障指令也有差异，为了简化开发，Java封了一套规范，也就是Java内存模型。

Java内存模型（Java Memory Model）是一种符合内存模型规范，屏蔽了硬件和操作系统的访问内存的各种差异，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。

![在这里插入图片描述](https://img-blog.csdnimg.cn/08061c61da0d44da9e681404ebcc6b1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_18,color_FFFFFF,t_70,g_se,x_16)

### 主内存 & 工作内存

-   主内存：线程之间的共享变量存储在主内存中。
-   工作内存：每个线程都有自己私有的本地内存，即工作内存，存储该线程读写共享变量的副本。

Java内存模型规定了：线程对变量的所有操作都必须在本地内存进行，不能直接读写主内存的变量。



## Java内存模型的八种操作

为了方便管理主内存与工作内存的交互，Java内存模型定义了八种操作：

1.   lock 锁定：作用于主内存变量，把一个变量标识为线程独占状态。
2.   unlock 解锁：作用于主内存变量，把一个变量从锁定状态释放出来，别的线程才能使用。
3.   read 读取：作用于主内存变量，将变量值从主内存读取到工作内存中。
4.   load 载入：作用于工作内存变量，将读取到的值放入工作内存的变量副本中。
5.   use 使用：作用于工作内存变量，将工作内存中的变量值传递给执行引擎。
6.   assign 赋值：作用于工作内存变量，将执行引擎接收到的值赋值给工作内存中的变量。
7.   store 存储：作用于工作内存变量，把工作内存中的变量值传递到主内存中，方便write操作。
8.   write 写入：作用于主内存变量，把store进来的值放入主内存中的变量。

![在这里插入图片描述](https://img-blog.csdnimg.cn/60823b74e859448dbf10548ce25b6ceb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_20,color_FFFFFF,t_70,g_se,x_16)



## 内存间交互操作的规则

-   不允许read和load、store和write操作之一单独出现，以上的操作必须按顺序执行，但不保证连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。
-   不允许一个线程丢弃它的最近都assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。（变量的值在工作内存中发生变化，必须回到主内存同步）
-   不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中
-   一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未初始化的变量，也就是对一个变量实施use和store操作之前，必须先执行过assign和load操作
-   一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一条线程重复只想，多次执行lock后，只有执行相同次数多unlock操作，变量才会被解锁
-   如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值
-   如果一个变量没有被lock操作锁定，则不允许对它执行unlock操作，也不能unlock一个被其他线程锁定的变量
-   对一个变量执行unlock操作之前，必须先把此变量同不会主内存，执行store和write操作



## volatile原理

volatile特性：可见性、有序性。

Java内存模型为了实现volatile有序性和可见性，定义了4中内存屏障的规范：LoadLoad/LoadStore/StoreLoad/StoreStore。

原理：在volatile前后加上内存屏障，使得编译器和CPU无法进行重排序，致使有序，并且写volatile变量堆其他线程可见。
