[TOC]

# JVM 执行引擎

## 概述

### 机器码

- 各种用0和1组成的二进制编码方式表示的指令，叫作机器指令码，简称机器码。
- 使用机器码编写的程序一经输入计算机，CPU可以直接读取运行，因此和其他语言编的程序相比，执行速度最快。
- 机器码与CPU紧密相关，所以不同种类的CPU所对应的机器码也就不同。

### 汇编语言

- 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov、inc等），可读性稍好，这就是我们常说的汇编语言。
- 不同的硬件平台，各自支持的指令是有差别的。因此每个平台所支持的指令，称为对应平台的指令集，如常见的x86指令集对应的是x86架构的平台，ARM指令集对应的是ARM架构的平台。不同平台之间指令不可以直接移植。
- 由于计算机只认识机器码，所以用汇编语言编写的程序还必须翻译成机器码，计算机才能识别和执行。

### 高级语言

- 为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。比如C、C++等更容易让人识别的语言。
- 当计算机执行高级语言编写的程序时，仍然需要把程序解释或编译成机器的指令码。完成这个过程的程序就叫作解释程序或编译程序

### 字节码

- 字节码是一种中间状态（中间码）的二进制代码（文件），需要转译后才能成为机器码。
- 字节码主要为了实现特定软件运行和软件环境，与硬件环境无关。
- Java程序可以通过编译器将源码编译成Java字节码，使用特定平台上的虚拟机将字节码转译为可以直接执行的指令，也就实现了跨平台性。



## Java代码编译和执行过程

- 物理机：以执行一系列的指令，物理机的执行引擎是直接建立在处理器、缓冲、指令集和操作系统层面上的。

- 虚拟机：不是真实存在的，虚拟机的执行引擎是由软件自行实现的。因此可以不受物理条件制约去制定指令集和执行引擎的结构体系，执行一些不被硬件直接支持的指令集格式。

### 执行引擎

执行引擎的任务就是将字节码指令解释／编译为对应平台上的机器码。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。

### 执行引擎工作流程

1. 执行引擎在执行的过程中需要执行什么样的字节码指令完全依赖程序计数器。
2. 每当执行玩一项指令操作后，程序计数器就会更新下一条需要执行的指令地址。
3. 方法在执行过程中，执行引擎有可能会通过存储在局部变量表中对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

![在这里插入图片描述](https://img-blog.csdnimg.cn/5178575e4bab4982870ccd3d995e8be8.png)

执行引擎充当了将class文件中的内容翻译为机器语言的译者，使得物理机器可以识别，进而使得程序可以执行。HotSpot VM中的执行引擎同时存在解释器和JIT编译器，即代码可以解释执行，也可以编译执行。从执行效率上讲，编译执行要比解释执行的效率高。从JVM启动时间来看，解释器可以首先发挥作用，而不必等待JIT全部编译完成后再执行，这样可以省去许多不必要的编译时间编译执行。此外，是否需要启动JIT编译器将字节码直接编译为对应平台的机器码需要根据代码被调用执行的频率而定，尽管如此，程序编译执行仍是未来的发展方向。

### 解释执行和编译执行

- 解释执行：将字节码指令逐条转换为机器码并执行。在 JDK 1.0 时代，JVM完全是解释执行的。
- 编译执行：将字节码直接编译为本地机器码并执行。

### 解释器和及时编译器

- 前端编译器：javac就是前端编译器，可以将Java文件编译为字节码文件。
- 解释器：Java虚拟机会根据规范堆字节码采用逐行解释的方式执行，将每条字节码文件中的内存翻译为对应的机器码指令执行。优势在于无序等待编译。
- 及时编译器（Just In-Time compiler，JIT，后端编译器）：以方法为单位，将热点代码的字节码直接编译为机器码，并缓存在本地，运行效率更高。

Java代码的执行可分为编译期和运行期：Java通过**前端编译器**将Java源代码编译为字节码，再通过**解释器**执行字节码，同时通过**及时编译器**的检测和编译热点代码提高执行效率。

###  Java是半编译半解释型语言

这是因为JVM在执行Java代码时，通常会将解释执行与编译执行二者结合进行的。



## 热点代码检测

- 方法计数器：监测方法执行频率；
- 循环计数器：检测循环执行频率。

![在这里插入图片描述](https://img-blog.csdnimg.cn/8cb1a1593a11458e997b33f996163f2f.png)



## -Xmixed -Xint -Xcomp

- -Xmixed：混合模式执行，为默认模式，开始解释执行，启动速度较快，对热点代码实行检测和编译。
- -Xint：仅解释模式执行，启动很快，执行稍慢。
- -Xcomp：仅编译模式执行，执行很快，启动很慢。

### 测试代码

```java
public class Demo {
    public static void main(String[] args) {
        for (int i = 0; i < 10_0000; i++) {
            test();
        }

        long start = System.currentTimeMillis();
        for (int i = 0; i < 10_0000; i++) {
            test();
        }
        long end = System.currentTimeMillis();
        System.out.println("耗时：" + (end - start));
    }

    public static void test() {
        for (long i = 0; i < 10_0000L; i++) {
            long j = i % 3;
        }
    }
}
```



### 测试 -Xmixed 混合模式

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c0b749aed0f416ea15f155949b16fff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

执行多次依次输出：

```
耗时：2185
耗时：2184
耗时：2184
```



### 测试 -Xint 仅解释模式

![在这里插入图片描述](https://img-blog.csdnimg.cn/d4ca7aefbb024b5098098131b5345fcb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

执行多次依次输出：

```
耗时：159085
耗时：159064
```



### 测试 -Xcomp 仅编译模式

![在这里插入图片描述](https://img-blog.csdnimg.cn/f6f3e235f4974469800d51b714e3b908.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

执行多次依次输出：

```
耗时：2187
耗时：2191
耗时：2186
```

