[TOC]

# JVM垃圾回收机制

## 概述

-   在内存中已经不再被使用到的内存空间就是垃圾。
-   Java堆区可以划分为年轻代（YoungGen）和老年代（OldGen），其中年轻代又可分为Eden区、S0区（from区）、S1区（to区）。



## 垃圾标记阶段

垃圾标记阶段用于判断对象是否可回收，只有被标记为已死亡的对象，GC才会在执行垃圾回收时，释放其占用的内存空间。在Java虚拟机中，判断对象是否存活的两种方式：

-   引用计数法
-   可达性分析法



### 引用计数法

每个对象都有一个引用计数器属性，当对象被引用+1，当对象失去引用-1；引用计数为0时，对象不再被引用，可以被回收。

**优点：**

-   简单
-   高效。

**缺点：**

-   需要单独的字段存储计数器，增加了内存开销；每次赋值需要更新计数器，增加了时间开销。
-   无法解决循环引用问题，目前在Java中几乎不使用这种算法。

```java
//循环引用 
Ref a = new Ref();
Ref b = new Ref();
a.reference = b;
b.reference = a;
```



### 可达性分析法（根搜索算法）

可达性分析法是以根对象集合（GC Roots）为起点，从这些节点开始向下搜索，搜索所走过的路径被称为**引用链**，当一个对象没有被任何引用链访问到时，则证明该对象是不活跃的，可以被回收。

![在这里插入图片描述](https://img-blog.csdnimg.cn/423d559dd3054a7d98b574da636d0561.png)

**GCRoots 说明：**

GCRoots 是一组活跃的引用。GCRoots 对象包含：

- 虚拟机栈（栈帧中的局部变量表）中引用的对象
- 方法区中的静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象
- 同步锁synchronized持有的对象



## 垃圾回收阶段

当区分出内存中存活对象和死亡对象后，GC接下来的任务是执行垃圾回收，释放掉死亡对象所占用的内存空间。

### 标记-清除算法

该算法分标记和清除两个阶段：

- 标记：首先从 GC Roots 开始搜索，标记垃圾对象，一般在对象头中标记；
- 清除：GC对堆内存进行遍历，统一回收标记的对象。

![在这里插入图片描述](https://img-blog.csdnimg.cn/0c0e1afdc3644f238dd909845a63cad3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_12,color_FFFFFF,t_70,g_se,x_16)

**优点：**

-   简单。

**缺点：**

- 效率问题：垃圾对象较多时，标记和清除两个过程的效率都不高，进行GC时，需要停止整个应用程序。
- 空间问题：标记-清除后会产生大量不连续的内存碎片，空间碎片太多会导致需要分配较大对象时，无法找到足够大的连续内存，而提前触发另外一次垃圾收集动作，非常浪费资源。



### 复制算法

**算法过程：**

核心思想：将内存空间分为大小相等的两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存中，之后清除正在使用的内存，交换两个内存的角色，最后完成垃圾回收。

这样使每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4b9b9636d964499786c1bf6a49f934dc.png)

**优点：**

-   没有标记和清除过程，实现简单，运行高效。
-   不会产生内存碎片问题。

**缺点：**

- 内存缩小为原来的一半，减少了实际可用的内存。
- 当存活对象较多时，需要做多次复制操作，效率将变低。

现在都商用虚拟机都采用这种收集算法来回收新生代。IBM公司的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Suvivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被浪费。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。



### 标记-整理算法

为了解决标记-复制算法的缺点，标记-整理算法出来了。

标记-清除算法是一种非移动式的回收算法，标记-整理是移动式的。

**算法过程：**

- 标记：标记存活对象；
- 整理：让所有存活的对象向一端移动；
- 清除：统一清除端以外的对象。

![在这里插入图片描述](https://img-blog.csdnimg.cn/c3e7805bb3584965ac07ba2fc0d55813.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhbmd4aW9uZ2ZseTkxNQ==,size_16,color_FFFFFF,t_70,g_se,x_16)

**优点：**

-   解决了标记-清除算法中，内存碎片问题。
-   解决了复制算法中，内存减半的缺点。

**缺点：**

- 效率上标记-整理算法低于复制算法。
- 移动对象时会触发STW。



### 三种算法对比

|          | 标记-清除算法      | 复制算法             | 标记-整理算法                           |
| -------- | ------------------ | -------------------- | --------------------------------------- |
| 速度     | 中等               | 最慢                 | 最快                                    |
| 内存开销 | 少，会产生内存碎片 | 少，不会产生内存碎片 | 需要存活对象的2倍空间，不会产生内存碎片 |
| 移动对象 | 否                 | 是                   | 是                                      |



### 分代收集算法

分代收集算法将内存划分为不同的区域进行管理，根据对象存活的周期不同存放在不同的区域，提高GC效率。假设将内存分为：新生代和老年代，将容易死亡的对象放在新生代，采用复制算法回收；将存活时间较长的对象放在老年代，采用标记-清除算法和标记-整理算法。

目前主流的虚拟机基本都采用该算法。

![在这里插入图片描述](https://img-blog.csdnimg.cn/de5ae2efa1274702a1f47ac20d8c5386.png)

**算法过程：**

![在这里插入图片描述](https://img-blog.csdnimg.cn/778bfb126c144874bd913b6a40fc263f.png)

1. 新创建的对象会先放在Eden区（位于新生代区，该区有大小限制），如果是大对象（如很长的字符串、数组）会直接分配到老年代区，避免频繁的内存复制。
2. 如果Eden区的空间占满，程序又需要创建对象时，会触发MinorGC，将Eden区的存活对象移动到S0区并销毁垃圾对象，新创建的对象会放在Eden区，这是第一轮MinorGC后的操作。
3. 当发生第二轮MinorGC后，会将存活Eden区和S0区的存活对象复制到S1区，并清除Eden区和S0区。
4. 每次MinorGC存活对象的年龄都会加1，当存活对象的年龄达到阀值（默认为15），存活对象会移动到老年代区。
5. 当老年代区内存不足时，会触发MajorGC，对老年代和新生代进行回收。当老年代内存仍不足时，会产生OOM异常。

**优点：**

- 效率高。
- 空间利用率高。



### 总结应用场景

-   标记-清除算法：适合使用在对象存活率较低、垃圾收集频率低的老年代区域。
-   复制算法：适合使用在对象存活率较低、需要频繁进行垃圾收集的新生代区域。
-   标记-整理算法：适合使用在对象存活率较低、垃圾收集频率低的老年代区域，老年代区是混合实现的。
-   分代手机算法：目前现在主流的虚拟机都采用分代收集算法，新生代采用复制算法，老年代采用标记-整理、标记-清除算法。



## GC类型

-   Minor GC/YoungGC(YGC)：新生代区空间不足时会触发。
-   Major GC/OldGC：老年代区空间不足时会触发，在Major GC之前一定会执行一次Minor GC。
-   Mixed GC：混合收集，收集整个新生代以及部分老年代，目前只有G1收集器会有这种行为。
-   Full GC(FGC)：收集整个Java堆和方法区，调用`System.gc()`或老年代空间不足、方法区空间不足时除非。



## Stop-the-World

Stop-the-World，简称STW，值GC发生时，会产生应用程序的停顿。停顿产生时整个应用程序都会被暂停，没有任何响应，像卡死一样，这个停顿称为STW。被STW中断的应用程序线程会在完成GC之后恢复。



## 垃圾收集器分类

查看垃圾收集器种类指令：`java -XX:+PrintCommandLineFlags -version`

-   Serial：串行收集，GC单线程内存回收，会暂停所有的用户线程。
-   Parallel：并行收集，多个GC线程并发工作，会暂停用户线程。
-   CMS：并发收集，用户线程和GC线程同时执行（不一定是并行，可能交替执行），不需要暂停用户线程。

